#!/usr/bin/env stack
{- stack
  --resolver lts-11.10
  --install-ghc
  runghc
  --package directory
  --package gitrev
  --package shake
-}
{-# LANGUAGE TemplateHaskell #-}
{-# OPTIONS_GHC -Wall -Werror #-}

module Main (main) where

import Control.Monad
import Data.Foldable
import Data.List (intersect, sort)
import Data.Semigroup ((<>))
import Data.Traversable
import Development.GitRev (gitHash)
import Development.Shake
import Development.Shake.FilePath
import qualified System.Directory as IO

options :: ShakeOptions
options = shakeOptions { shakeColor = True }

main :: IO ()
main = do
    restylers <- filterM hasDockerfile . sort =<< IO.listDirectory "."

    shakeArgs options $ do
        for_ restylers $ \name -> do
            builtImage name %> \out -> do
                need =<< getTrackedContents name
                cmd_ "docker" ["build", "--tag", imageName name, name]
                writeFile' out ""

            testedImage name %> \out -> do
                let test = "test" </> name <.> "t"
                need [builtImage name, test]
                cmd_ "cram" [test]
                writeFile' out ""

            pushedImage name %> \out -> do
                need [builtImage name]
                cmd_ "docker" ["tag", imageName name, shaImageName name]
                cmd_ "docker" ["push", shaImageName name]
                writeFile' out $ shaImageName name

        "manifest" %> \out -> do
            need $ map testedImage restylers
            need $ map pushedImage restylers
            contents <- for restylers $ \name -> do
                -- Minor compatibility shim for existing images that were built
                -- and pushed as :latest and before we implemented the manifest
                image <- readFile' $ pushedImage name
                pure $ if null image then imageName name else image
            writeFile' out $ unlines contents

        want ["manifest"]

imageName :: String -> String
imageName = ("restyled/restyler-" <>)

shaImageName :: String -> String
shaImageName name = imageName name <> ":" <> take 7 $(gitHash)

builtImage :: String -> FilePath
builtImage f = ".shake" </> "tmp" </> f

testedImage :: String -> FilePath
testedImage f = ".shake" </> "tmp" </> f <.> "tested"

pushedImage :: String -> FilePath
pushedImage f = ".shake" </> "tmp" </> f <.> "pushed"

hasDockerfile :: FilePath -> IO Bool
hasDockerfile = IO.doesFileExist . (</> "Dockerfile")

getTrackedContents :: FilePath -> Action [FilePath]
getTrackedContents path = do
    Stdout output <- cmd "git" ["ls-files", path]
    contents <- map (path </>) <$> getDirectoryFiles path ["**/*"]
    pure $ contents `intersect` lines output

-- vim: ft=haskell
