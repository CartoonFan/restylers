#!/usr/bin/env stack
{- stack
  --resolver lts-11.10
  --install-ghc
  runghc
  --package directory
  --package gitrev
  --package shake
-}
{-# LANGUAGE TemplateHaskell #-}
{-# OPTIONS_GHC -Wall -Werror #-}

module Main (main) where

import Control.Monad
import Data.List (intersect)
import Data.Foldable
import Data.Semigroup ((<>))
import Development.Shake
import Development.Shake.FilePath
import Development.GitRev (gitHash)
import qualified System.Directory as IO

options :: ShakeOptions
options = shakeOptions { shakeColor = True }

main :: IO ()
main = do
    restylers <- filterM hasDockerfile =<< IO.listDirectory "."

    shakeArgs options $ do
        for_ restylers $ \name -> do
            builtImage name *%> \_ -> do
                need =<< getTrackedContents name
                cmd_ "docker" ["build", "--tag", imageName name, name]

            testedImage name *%> \_ -> do
                let test = "test" </> name <.> "t"
                need [builtImage name, test]
                cmd_ "cram" [test]

            pushedImage name *%> \_ -> do
                need [builtImage name]
                cmd_ "docker" ["tag", imageName name, shaImageName name]
                cmd_ "docker" ["push", shaImageName name]

        want $ map testedImage restylers
        want $ map pushedImage restylers

imageName :: String -> String
imageName = ("restyled/restyler-" <>)

shaImageName :: String -> String
shaImageName name = imageName name <> ":" <> take 7 $(gitHash)

builtImage :: String -> FilePath
builtImage f = ".shake" </> "tmp" </> f

testedImage :: String -> FilePath
testedImage f = ".shake" </> "tmp" </> f <.> "tested"

pushedImage :: String -> FilePath
pushedImage f = ".shake" </> "tmp" </> f <.> "pushed"

hasDockerfile :: FilePath -> IO Bool
hasDockerfile = IO.doesFileExist . (</> "Dockerfile")

getTrackedContents :: FilePath -> Action [FilePath]
getTrackedContents path = do
    Stdout output <- cmd "git" ["ls-files", path]
    contents <- map (path </>) <$> getDirectoryFiles path ["**/*"]
    pure $ contents `intersect` lines output

(*%>) :: FilePattern -> (FilePath -> Action ()) -> Rules ()
stateFile *%> rule = stateFile %> \out -> do
    rule out
    writeFile' out ""

-- vim: ft=haskell
