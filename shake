#!/usr/bin/env stack
-- stack script --resolver lts-13.13
{-# LANGUAGE TemplateHaskell #-}
{-# OPTIONS_GHC -Wall #-}

module Main (main) where

import Control.Monad
import Control.Exception.Safe (throwString)
import Data.Maybe (fromMaybe)
import Data.Foldable (for_)
import Data.List (sort, stripPrefix)
import Data.Semigroup ((<>))
import Development.GitRev
import Development.Shake
import Development.Shake.FilePath

options :: ShakeOptions
options = shakeOptions
    { shakeChange = ChangeModtimeAndDigest
    , shakeColor = True
    }

main :: IO ()
main = shakeArgs options $ do
    -- Pull and write state files for all minifested images in the manifest, to
    -- initialize a build cache with the assumption everything's been built,
    -- tested, and pushed already.
    phony "setup" $ do
        images <- lines <$> readFile' "manifest"

        for_ images $ \image -> do
            cmd_ "docker" ["pull", image]

            let name = unShaImageName image
            writeFile' (name </> "Dockerfile.built") image
            writeFile' (name </> "Dockerfile.tested") image
            writeFile' (name </> "Dockerfile.pushed") image

    want ["manifest"]

    -- A simple text file of the image tags we most-recently pushed, to make it
    -- less error-prone to copy/paste into the Restyler code that uses it.
    "manifest" %> \out -> do
        dockerfiles <- getDirectoryFiles "" ["*/Dockerfile"]
        need $ map (<.> "pushed") dockerfiles
        contents <- traverse (readFile' . (<.> "pushed")) dockerfiles
        writeFile' out $ unlines $ sort contents

    -- Evidence that we've pushed a tested image, built from the Dockerfile.
    -- This will refuse to run if the working directory is not clean, since that
    -- could be pushing over an existing tag.
    "*" </> "Dockerfile.pushed" %> \out -> do
        need [out -<.> "tested"]

        unless cleanWorkingDirectory $ liftIO $ throwString
            "Refusing to push without clean working directory"

        let name = takeDirectory out
        cmd_ "docker" ["tag", imagePrefix <> name, shaImageName name]
        cmd_ "docker" ["push", shaImageName name]
        writeFile' out $ shaImageName name

    -- Evidence that we've tested the image built from the Dockerfile. This will
    -- only run if the image is re-built or the test file itself changes.
    "*" </> "Dockerfile.tested" %> \out -> do
        let name = takeDirectory out
            test = "test" </> name <.> "t"
        need [out -<.> "built", test]
        cmd_ "cram" [test]
        writeFile' out ""

    -- Evidence that we've built the image from the Dockerfile. This will only
    -- run if the Dockerfile itself changes.
    "*" </> "Dockerfile.built" %> \out -> do
        let name = takeDirectory out
        need [out -<.> ""]
        cmd_ "docker" ["build", "--tag", imagePrefix <> name, name]
        writeFile' out ""

-- | Registry prefix used for released images
imagePrefix :: String
imagePrefix = "restyled/restyler-"

-- | The released image tagged with current commit
shaImageName :: String -> String
shaImageName name = imagePrefix <> name <> ":" <> take 7 $(gitHash)

-- | Reverse of @'shaImageName'@
unShaImageName :: String -> String
unShaImageName = takeWhile (/= ':') . fromMaybe err . stripPrefix imagePrefix
  where
    err = error "unShaImageName used on image without imagePrefix"

-- | Returns @'True'@ for a clean working directory
cleanWorkingDirectory :: Bool
cleanWorkingDirectory
    | $(gitDirty) = False
    | $(gitDirtyTracked) = False
    | otherwise = True

-- vim: ft=haskell
